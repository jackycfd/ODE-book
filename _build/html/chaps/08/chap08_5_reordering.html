

<!DOCTYPE html>


<html >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>8.5. Reordering and Matrix Bandwidth &#8212; Computational Methods in Ordinary Differential Equations</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/exercise.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'chaps/08/chap08_5_reordering';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="8.9. Chapter 8 Exercises" href="chap08_6_exercise.html" />
    <link rel="prev" title="8.4. Sparse Matrices Storage and Reordering" href="chap08_4_storage.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="None"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo4.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../../_static/logo4.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../index.html">
                    Linear Multi-step Methods
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Unit Guide</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../unitguide/schedule.html">Teaching Schedule</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../unitguide/readinglist.html">Reading List</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Lecture Notes and Tutorial Exericses</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../01/chap01_0.html">1. Complex Numbers and Difference Equations</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../01/chap01_1_complexNumber.html">1.1. Complex Numbers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../01/chap01_2_sequence.html">1.2. Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../01/chap01_3_differenceEquation.html">1.3. Difference Equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../01/chap01_4_homogenous.html">1.4. Homogeneous Linear Difference Equations with Constant Coefficients</a></li>
<li class="toctree-l2"><a class="reference internal" href="../01/chap01_5_exercise.html">1.5. Chapter 1 Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../02/chap02_0.html">2. Interpolating Polynomial</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../02/chap02_1_introduction.html">2.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../02/chap02_2_differenceOperator.html">2.2. Finite Difference Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../02/chap02_3_interpolation.html">2.3. Gregory-Newton Interpolation Formulae</a></li>
<li class="toctree-l2"><a class="reference internal" href="../02/chap02_4_differenceTable.html">2.4. Finite Difference Tables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../02/chap02_5_exercise.html">2.5. Chapter 2 Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../03/chap03_0.html">3. Multistep Methods: Derivation by Finite Difference formulae</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../03/chap03_1_multistepMethod.html">3.1. Multistep Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../03/chap03_2_derivation.html">3.2. Derivation of Multistep Methods by Numerical Integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../03/chap03_3_explicit.html">3.3. Explicit or Open Multistep Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../03/chap03_4_implicit.html">3.4. Implicit or Closed Multistep Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../03/chap03_5_predictorCorrector.html">3.5. Predictor-Corrector Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../03/chap03_6_matlab.html">3.6. Example MATLAB Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../03/chap03_7_python.html">3.7. Example Python Codes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../03/chap03_8_exercise.html">3.8. Chapter 3 Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../04/chap04_0.html">4. Multistep Methods: Order and Error Constants</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../04/chap04_1_errorIntegration.html">4.1. Derivation of Local Error Terms for Integration Formulae</a></li>
<li class="toctree-l2"><a class="reference internal" href="../04/chap04_2_errorConstant.html">4.2. Order and Error Constants</a></li>
<li class="toctree-l2"><a class="reference internal" href="../04/chap04_3_MilineDevice.html">4.3. Estimate of truncation error at each step for Predictor-Corrector methods – Milne’s Device</a></li>
<li class="toctree-l2"><a class="reference internal" href="../04/chap04_4_exercise.html">4.4. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../05/chap05_0.html">5. Multistep Methods: Stability I</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../05/chap05_1_rootCondition.html">5.1. Characteristic Polynomials and Root Condition</a></li>
<li class="toctree-l2"><a class="reference internal" href="../05/chap05_2_convergence.html">5.2. Zero-Stability, Consistency and Convergence Theorem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../05/chap05_3_exercise.html">5.3. Chapter 5 Exercise</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../06/chap06_0.html">6. Multistep Methods: Stability II</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-6"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../06/chap06_1_stabilityInterval.html">6.1. Interval and Region of Absolute Stability</a></li>
<li class="toctree-l2"><a class="reference internal" href="../06/chap06_2_rootLocus.html">6.2. The Root Locus Method for Finding the Interval of Absolute Stability</a></li>
<li class="toctree-l2"><a class="reference internal" href="../06/chap06_3_boundaryRootLocus.html">6.3. The Boundary Root Locus Method for Finding Regions of Absolute Stability</a></li>
<li class="toctree-l2"><a class="reference internal" href="../06/chap06_4_exampleCode.html">6.4. Example MATLAB Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../06/chap06_5_exercise.html">6.5. Chapter 6 Exercises</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../07/chap07_0.html">7. An Introduction to Stiff Differential Equations</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-7"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../07/chap07_1_introduction.html">7.1. Introduction and background</a></li>
<li class="toctree-l2"><a class="reference internal" href="../07/chap07_2_stiffSystem.html">7.2. Stiff Systems of Differential Equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../07/chap07_3_method.html">7.3. Methods for Stiff Equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../07/chap07_4_codeExample.html">7.4. Example MATLAB Program</a></li>
<li class="toctree-l2"><a class="reference internal" href="../07/chap07_5_exercise.html">7.5. Chapter 7 Exercise</a></li>
</ul>
</li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="chap08_0.html">8. Computational Methods with Sparse Matrices</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-8"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="chap08_1_introduction.html">8.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="chap08_2_sparseMatrix.html">8.2. Sparse Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="chap08_3_graphTheory.html">8.3. Matrix Sparsity and Graph Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="chap08_4_storage.html">8.4. Sparse Matrices Storage and Reordering</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">8.5. Reordering and Matrix Bandwidth</a></li>



<li class="toctree-l2"><a class="reference internal" href="chap08_6_exercise.html">8.9. Chapter 8 Exercises</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Documentation of Ordinary Differential Equation Solvers</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../chapX_odeSolvers.html">Matlab ODE Solvers</a></li>

<li class="toctree-l1"><a class="reference internal" href="../markdown-notebooks.html">Notebooks with MyST Markdown</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/chaps/08/chap08_5_reordering.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Reordering and Matrix Bandwidth</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">8.5. Reordering and Matrix Bandwidth</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cuthill-and-mckee-reordering">8.5.1. Cuthill and McKee Reordering</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#column-count-reordering">8.6. Column Count Reordering</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#minimum-degree-reordering">8.7. Minimum Degree Reordering</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#comparison-between-various-ordering-schemes-and-fill-in-effect">8.8. Comparison between various ordering schemes and fill-in effect</a></li>
</ul>

            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section id="reordering-and-matrix-bandwidth">
<h1><span class="section-number">8.5. </span>Reordering and Matrix Bandwidth<a class="headerlink" href="#reordering-and-matrix-bandwidth" title="Permalink to this headline">#</a></h1>
<p>During the process of matrix factorization into a product by methods
such as Gaussian elimination and Cholesky factorization, there will
always be a problem with fill-in that is generating additional nonzero
elements during the elimination process (i.e. row operation). Hence we
are unable to take advantage of the sparsity feature of the original
matrix and end up wasting both storage and computational time. Therefore
the problem is how to perform row operations whilst minimizing the
fill-in of nonzero elements. One way to achieve this is to try to
position the nonzero elements near the main or principal diagonal, so
that reordering of rows and columns will not result in additional
nonzero elements. The process of moving the nonzero element near the
principal diagonal is the same as reducing the profile or the bandwidth
of the matrix.</p>
<p>Consider an <span class="math notranslate nohighlight">\(n \times n\)</span> matrix <span class="math notranslate nohighlight">\(A=(a_{ij})\)</span>. If all matrix elements are
zero outside a diagonally confined band whose range is determined by
constants <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span>;</p>
<p><span class="math notranslate nohighlight">\(a_{ij}=0\)</span> <span class="math notranslate nohighlight">\(\text{if}\)</span> <span class="math notranslate nohighlight">\(j&lt;i-p\)</span> <span class="math notranslate nohighlight">\(\text{or}\)</span> <span class="math notranslate nohighlight">\(j&gt;i+q\)</span>; <span class="math notranslate nohighlight">\(p,q \geq 0\)</span> (or
<span class="math notranslate nohighlight">\(j-i&gt;p\)</span>, or <span class="math notranslate nohighlight">\(i-j&gt;q\)</span>; <span class="math notranslate nohighlight">\(p, q \geq 0\)</span> ), where <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span> are the
distances above and below the main diagonal, then the bandwidth <span class="math notranslate nohighlight">\(bw\)</span> is
given by <span class="math notranslate nohighlight">\(bw=p+q+1\)</span> (in other words, it is the smallest number of
adjacent diagonals to which the non-zero elements are confined). A
matrix is called a band matrix or banded matrix if its bandwidth is
reasonably small. A band matrix with <span class="math notranslate nohighlight">\(p=q=0\)</span> is a diagonal matrix; $A=</p>
<div class="amsmath math notranslate nohighlight" id="equation-f2f6239f-b0ef-40d8-99b6-d85240459761">
<span class="eqno">(8.7)<a class="headerlink" href="#equation-f2f6239f-b0ef-40d8-99b6-d85240459761" title="Permalink to this equation">#</a></span>\[\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0  \\
0 &amp; 1 &amp; 0 &amp; 0  \\
0 &amp; 0 &amp; 1 &amp; 0  \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}\]</div>
<div class="amsmath math notranslate nohighlight" id="equation-8e1516ce-85b6-4c54-8d6f-ec27b7c8c400">
<span class="eqno">(8.8)<a class="headerlink" href="#equation-8e1516ce-85b6-4c54-8d6f-ec27b7c8c400" title="Permalink to this equation">#</a></span>\[\begin{bmatrix}
1 &amp; 1 &amp; 0 &amp; 0  \\
1 &amp; 1 &amp; 1 &amp; 0  \\
0 &amp; 1 &amp; 1 &amp; 1  \\
0 &amp; 0 &amp; 1 &amp; 1
\end{bmatrix}\]</div>
<p>given in the following table, using the conventional numbering used in
MATLAB.</p>
<div class="highlight-center notranslate"><div class="highlight"><pre><span></span>   $i$   $j$   $[i,j]$
  ----- ----- ---------
    1     1    \[1,1\]
    2     1    \[2,1\]
    1     2    \[1,2\]
    2     2    \[2,2\]
    3     2    \[3,2\]
    2     3    \[2,3\]
    3     3    \[3,3\]
    4     3    \[4,3\]
    3     4    \[3,4\]
    4     4    \[4,4\]
</pre></div>
</div>
<p>Therefore, the difference between i and j for each nonzero entry is
either 0 or 1; hence the maximum distance is 1, i.e. in MATLAB the
bandwidth calculation for a tridiagonal matrix <span class="math notranslate nohighlight">\(T\)</span> is performed by the
following commands:-</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>% Calculate bandwidth of a given matrix

&gt;&gt; T =[
     1     1     0     0
     1     1     1     0
     0     1     1     1
     0     0     1     1]

&gt;&gt; [i,j]=find(T);
&gt;&gt; bw=max(i-j)

bw =
     1
</pre></div>
</div>
<p>Note:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[i,j]=find(T); %returns the row and column indices for
               % the nonzero entries
bw=max(i-j)    %returns an array the same size as i
               %and j with the largest elements taken
               %from i or j.
               %the dimensions of i and j must match.
</pre></div>
</div>
<p>Note - in some textbooks and articles the bandwidth is given as
<span class="math notranslate nohighlight">\(bw=p+q+1\)</span> - the bandwidth of a tridiagonal matrix is given as 3 (i.e.
<span class="math notranslate nohighlight">\(1(L) + 1(U) + 1(D)\)</span>). Also, when <span class="math notranslate nohighlight">\(p=q=2\)</span> one has a pentadiagonal matrix
and so on. Also, an upper triangular matrix is obtained when <span class="math notranslate nohighlight">\(q=0\)</span>,
<span class="math notranslate nohighlight">\(q=n-1\)</span>, and similarly, with <span class="math notranslate nohighlight">\(p=n-1\)</span>, <span class="math notranslate nohighlight">\(q=0\)</span>, a lower triangular matrix
is obtained.</p>
<section id="cuthill-and-mckee-reordering">
<h2><span class="section-number">8.5.1. </span>Cuthill and McKee Reordering<a class="headerlink" href="#cuthill-and-mckee-reordering" title="Permalink to this headline">#</a></h2>
<p>The most simple and popular method of minimizing the bandwidth was
developed by Cuthill and McKee (1969). Later the method was improved by
Alan George who developed the Reverse Cuthill and McKee (RCM) method
which is much more effective than the original CM algorithm. There are
several other efficient bandwidth reduction methods used in re-ordering
of sparse matrices, namely Minimum Degree Reordering method. The Cuthill
and McKee algorithm is outlined in the following steps:-</p>
<ol class="arabic simple">
<li><p>For a given sparse symmetric matrix, plot the adjacency graph
(alternatively if you have been given the adjacency graph, then it
is useful to write down the corresponding adjacency matrix).</p></li>
<li><p>Look at all the nodes, and produce a table listing the node numbers
and the number of connections (or degree).</p></li>
<li><p>Select the node with the lowest degree (say <span class="math notranslate nohighlight">\(n_1\)</span>) and write it down
under a column heading ‘Result/Head’. If there is more than one node
with the same number of degree, then choose one of them and write it
down.</p></li>
<li><p>Look at the nodes connected directly to node <span class="math notranslate nohighlight">\(n_1\)</span>, write down in
the next column ‘Queue’ the nodes that are connected to <span class="math notranslate nohighlight">\(n_1\)</span>, in
the order with lowest degree (e.g. <span class="math notranslate nohighlight">\(n_2\)</span>, <span class="math notranslate nohighlight">\(n_3\)</span>, <span class="math notranslate nohighlight">\(n_4\)</span>) that has not
appeared in the Result column before.</p></li>
<li><p>Extract the first node in the queue - say <span class="math notranslate nohighlight">\(n_2\)</span>, if <span class="math notranslate nohighlight">\(n_2\)</span> has not
been previously inserted in ‘Result’ then write <span class="math notranslate nohighlight">\(n_2\)</span> below <span class="math notranslate nohighlight">\(n_1\)</span>
and check again for the connections. Since <span class="math notranslate nohighlight">\(n_4\)</span> is already in the
queue, you need to see if <span class="math notranslate nohighlight">\(n_2\)</span> is connected to any other nodes, say
<span class="math notranslate nohighlight">\(n_5\)</span> write down in the queue column <span class="math notranslate nohighlight">\(n_4\)</span> if <span class="math notranslate nohighlight">\(n_2\)</span> was not
connected to a new node, just leave a blank in the queue column.</p></li>
<li><p>Now, write down <span class="math notranslate nohighlight">\(n_3\)</span> below <span class="math notranslate nohighlight">\(n_2\)</span> in the Results column, and repeat
step 4.</p></li>
<li><p>Repeat steps 4 to 6 until there are no more nodes left to be
considered.</p></li>
<li><p>Look at your list in the column Result - and renumber these as new
node numbers.</p></li>
<li><p>Continue until the size of the array Result is <span class="math notranslate nohighlight">\(n\)</span> for an
<span class="math notranslate nohighlight">\(n\times n\)</span> matrix (i.e. all nodes are included in the array).</p></li>
</ol>
<p>Note:- If the selected node in column Results is not connected to any
other node, then we put a ‘-’ in the corresponding position in the queue
column.</p>
<p><strong>[Example 7.1]{.underline}</strong> Consider the following sparse matrix and
its corresponding adjacency plot:</p>
<div class="highlight-center notranslate"><div class="highlight"><pre><span></span>$A=
      \begin{bmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
        0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
        1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
        0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
        0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1
      \end{bmatrix}$
</pre></div>
</div>
<div class="highlight-center notranslate"><div class="highlight"><pre><span></span>![image](main/07/Fig7a.tikz){width=&quot;5cm&quot;}
</pre></div>
</div>
<div class="highlight-center notranslate"><div class="highlight"><pre><span></span>
::: tabular
P2cm \| P2cm P2cm P2cm P2cm P2cm Original nodes &amp; No. of connections &amp;
Results/ Head &amp; Queue &amp; RCM &amp; New nodes\
1 &amp; 1 &amp; 1 &amp; 5 &amp;7 &amp;1\
2 &amp; 3 &amp; 5 &amp; 3 &amp;4 &amp;2\
3 &amp; 2 &amp; 3 &amp; 2 &amp;8 &amp;3\
4 &amp; 1 &amp; 2 &amp; 6,8 &amp;6 &amp;4\
5 &amp; 2 &amp; 6 &amp; - &amp;2 &amp;5\
6 &amp; 2 &amp; 8 &amp; - &amp;3 &amp;6\
7 &amp; 1 &amp; 4 &amp; 7 &amp;5 &amp;7\
8 &amp; 2 &amp; 7 &amp; - &amp;1 &amp;8\
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
Note that the labels of new nodes are the reverse of the elements in the
array Results. See below the re-ordered matrix and the adjacency graph
(note the diagram remains unchanged, but nodes are now relabelled).

::: center
$B=
        \begin{bmatrix}
          1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
          1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
          0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
          0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
          0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
          0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 \\
          0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\
          0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1
        \end{bmatrix}$
</pre></div>
</div>
<div class="highlight-center notranslate"><div class="highlight"><pre><span></span>![image](main/07/Fig7b.tikz){width=&quot;5cm&quot;}
</pre></div>
</div>
<p>It can be seen that the algorithm keeps all nonzero elements close to
the diagonal. You can see visibly that there are more zero elements
below and above the main diagonal and nonzero elements are close to the
main diagonal and the re-ordered matrix exhibits a banded structure.
Using MATLAB the bandwidths of the original matrix A and the reordered
matrix B can be found as:-</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  &gt;&gt; [i,j]=find(A); %returns the row and col indices
                    %of the nonzero entries
  &gt;&gt; bw=max(i-j)
  bw =6
  
  &gt;&gt; [i,j]=find(B);
  &gt;&gt; bw=max(i-j)
  bw =2
</pre></div>
</div>
<p>i.e. The (half) bandwidth of the matrix has been reduced to 2 instead of
6; hence, the full bandwidth of the matrices A and B are 13 and 5
respectively. Note that the relabeling described above used the reverse
of the array RCM of the reordered nodes, hence this is the Reverse
Cuthill-McKee (RCM) re-ordering technique. In the original Cuthill-McKee
(CM) algorithm, the elements of array Results are relabelled without
reversing the elements. i.e.</p>
<div class="highlight-center notranslate"><div class="highlight"><pre><span></span>    Original nodes 1   2   3   4   5   6   7   8      
  ---------------- --- --- --- --- --- --- --- --- -- --
     Cuthill-McKee 1   5   3   2   6   8   4   7      
        Reverse CM 7   4   8   6   2   3   5   1      
</pre></div>
</div>
<p>In MATLAB, the command <span class="math notranslate nohighlight">\(symrcm(A)\)</span> returns the symmetric reverse
Cuthill-McKee ordering of A. This is a permutation matrix p such that
<span class="math notranslate nohighlight">\(A(p,p)\)</span> tends to have its nonzero elements closer to the main diagonal.
Example MATLAB code:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  p = symrcm(A);
  spy(A(p,p)), title(&#39;A(p,p) after Cuthill-McKee ordering&#39;)
  nz = nnz(A);
  pct = 100/numel(A);
  xlabel(sprintf(&#39;nonzeros=%d (%.1f%%)&#39;,nz,nz*pct));
</pre></div>
</div>
<figure>
<div class="center">
<img src="main/07/example7_1fig1.tikz" style="width:6cm" />
</div>
</figure>
<p>Figure 5 below shows the nonzero pattern of the original matrix A, the
ordered matrix B, matrix C, ordered by the CM method, and matrix D is
found by using the MATLAB function <span class="math notranslate nohighlight">\(\emph{symrcm}\)</span>:-</p>
<figure>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"><img src="main/07/example7_1sub1.tikz"
style="width:6cm" alt="image" /></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><img src="main/07/example7_1sub2.tikz"
style="width:6cm" alt="image" /></td>
</tr>
<tr class="even">
<td style="text-align: center;"><img src="main/07/example7_1sub3.tikz"
style="width:6cm" alt="image" /></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><img src="main/07/example7_1sub4.tikz"
style="width:6cm" alt="image" /></td>
</tr>
</tbody>
</table>
</div>
</figure>
<p>Note that the half bandwidth of the reordered matrix <span class="math notranslate nohighlight">\(C\)</span>, using the
original Cuthill-Mckee method is <span class="math notranslate nohighlight">\(bw =5\)</span>, and the half bandwidth of the
reordered matrix <span class="math notranslate nohighlight">\(D\)</span> is <span class="math notranslate nohighlight">\(bw =2\)</span>, using the MATLAB function <span class="math notranslate nohighlight">\(sysmrcm\)</span> for
the reverse Cuthill-Mckee is <span class="math notranslate nohighlight">\(bw =2\)</span>, i.e. the same as that for matrix
<span class="math notranslate nohighlight">\(B\)</span>. Hence, the Reverse Cuthill-Mckee algorithm for bandwidth reduction
of sparse matrices seems to be the most effective reordering method.</p>
</section>
</section>
<section id="column-count-reordering">
<h1><span class="section-number">8.6. </span>Column Count Reordering<a class="headerlink" href="#column-count-reordering" title="Permalink to this headline">#</a></h1>
<p>The idea of the column count reordering algorithm is to move rows and
columns with higher nonzero count towards the end of the matrix. This
algorithm reduces the time and storage for computing matrix operations
such as the LU factorization and the Cholesky factorization, but its
performance is not consistent overall and depends on the original
matrix. <strong>[Example 7.2]{.underline}</strong> Consider the sparse matrix and its
corresponding adjacency graph from Example 7.1:</p>
<div class="highlight-center notranslate"><div class="highlight"><pre><span></span>$A=
        \begin{bmatrix}
          1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
          0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
          0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
          0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
          1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
          0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
          0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
          0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1
        \end{bmatrix}$
</pre></div>
</div>
<div class="highlight-center notranslate"><div class="highlight"><pre><span></span>![image](main/07/Fig7a.tikz){width=&quot;5cm&quot;}
</pre></div>
</div>
<p>The degrees of all vertices are obtained in the following:</p>
<div class="highlight-center notranslate"><div class="highlight"><pre><span></span>  vertex          1   2   3   4   5   6   7   8
  --------------- --- --- --- --- --- --- --- ---
  no. of degree   1   3   2   1   2   2   1   2
</pre></div>
</div>
<p>Since vertex 7 has the least degrees, it is labelled as 1 - (Note: since
vertices 1, 4, and 7 have the same number of degrees, therefore the new
labels are interchangeable, as any of these vertices can be chosen in
any order) and then vertices 4 and 1 are labelled (again since vertices
4 and 1 have the same number of degrees, therefore the new labels are
interchangeable). The algorithm is then continued in the same steps
until complete labelling is obtained as shown:</p>
<div class="highlight-center notranslate"><div class="highlight"><pre><span></span>  new vertex   1   2   3   4   5   6   7   8
  ------------ --- --- --- --- --- --- --- ---
  old vertex   7   4   1   8   6   5   3   2
</pre></div>
</div>
<p>The resulting adjacency matrix and graph are shown below:</p>
<div class="highlight-center notranslate"><div class="highlight"><pre><span></span>$CC=
        \begin{bmatrix}
          1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
          1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
          0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
          0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\
          0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\
          0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\
          0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\
          0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1
        \end{bmatrix}$
</pre></div>
</div>
<p><img alt="image" src="chaps/08/main/07/F7CCalog.tikz" />{width=”5cm”}</p>
<p>Similar to the command <span class="math notranslate nohighlight">\(\emph{symrcm}\)</span> for RCM reordering, in MATLAB the
command <span class="math notranslate nohighlight">\(\emph{colperm}\)</span> returns the column count reordering of A. This
is a permutation matrix q such that <span class="math notranslate nohighlight">\(A(q,q)\)</span> tends to move rows and
columns with higher nonzero count towards the end of the matrix (a
down-arrow effect).</p>
<p>Example MATLAB code:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  q = colperm(A);
  spy(A(q,q)),title(&#39;A(q,q)-Column Count ordering by colperm&#39;)
  nz = nnz(A);
  pct = 100 / numel(A);
  xlabel(sprintf(&#39;nonzeros=%d (%.1f%%)&#39;,nz,nz*pct));
</pre></div>
</div>
<figure>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"><img src="main/07/cc_comb_1.tikz"
style="width:40.0%" alt="image" /></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><img src="main/07/cc_comb_2.tikz"
style="width:40.0%" alt="image" /></td>
</tr>
</tbody>
</table>
</div>
</figure>
</section>
<section id="minimum-degree-reordering">
<h1><span class="section-number">8.7. </span>Minimum Degree Reordering<a class="headerlink" href="#minimum-degree-reordering" title="Permalink to this headline">#</a></h1>
<p>The minimum degree algorithm attempts to reduce the fill-in caused by
elimination such as Gaussian elimination, LU decomposition or the
Cholesky decomposition. The computational costs of this algorithm is
inexpensive, and it is easy to apply and effective for most problems
which are not too large. However, most mathematical software packages
such as MATLAB use an approximation minimum degree, rather than the
exact degree to minimise the computational costs. The minimum degree
algorithm is re-labelling of the vertices in ascending degree order.
Nodes with lower degrees are labelled early to reduce adding many
fill-ins.</p>
<p><strong>[Example 7.3]{.underline}</strong> Consider the sparse matrix and its
corresponding adjacency graph from Example 7.1:</p>
<div class="highlight-center notranslate"><div class="highlight"><pre><span></span>$A=
        \begin{bmatrix}
          1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
          0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
          0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
          0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
          1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
          0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
          0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
          0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1
       \end{bmatrix}$
</pre></div>
</div>
<div class="highlight-center notranslate"><div class="highlight"><pre><span></span>![image](main/07/Fig7a.tikz){width=&quot;4cm&quot;}
</pre></div>
</div>
<p>The minimum degree algorithm is re-labelling of the vertices in
ascending degree order. Nodes with lower degrees are labelled early to
reduce adding many fill-ins.</p>
<p>The degrees of all vertices are shown in the following table:</p>
<div class="highlight-center notranslate"><div class="highlight"><pre><span></span>           vertex 1   2   3   4   5   6   7   8
  --------------- --- --- --- --- --- --- --- ---
    no. of degree 1   3   2   1   2   2   1   2
</pre></div>
</div>
<p>where vertex 7 has the least degrees, then vertex 7 is numbered with
first as 1. Since vertex 7 is connected to vertex 4, then vertex 4 must
be updated by subtracting 1 (if it is already 1 then just write it down
as 1 and number it immediately after 7) as shown in the following
Table - where the eliminated node is represented by X , and the vertex
is numbered with a new label. Note: if no tie-breaking strategy has been
established, all three vertices 1, 4, and 7 can be selected in this
case, and proceed to elimination. The completed ordering using the
Minimum Degree algorithm is shown in the following table, together with
the resulting adjacency matrix and graph:</p>
<div class="highlight-center notranslate"><div class="highlight"><pre><span></span>  --- -------------- -------------------------- --- --- --- --- --- --- ---
                      vertex and no. of degree                          
                                 1               2   3   4   5   6   7   8
       New ordering              1               3   2   1   2   2   1   2
   1      \(7\)                  1               3   2   1   2   2   X   2
   2      \(4\)                  1               3   2   X   2   2   X   2
   3      \(1\)                  X               3   2   X   1   2   X   2
   4      \(5\)                  X               3   1   X   X   2   X   2
   5      \(3\)                  X               2   X   X   X   2   X   2
   6      \(6\)                  X               1   X   X   X   X   X   1
   7      \(8\)                  X               1   X   X   X   X   X   X
   8      \(2\)                  X               X   X   X   X   X   X   X
  --- -------------- -------------------------- --- --- --- --- --- --- ---
</pre></div>
</div>
<div class="highlight-center notranslate"><div class="highlight"><pre><span></span>$MD=
        \begin{bmatrix}
          1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
          1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
          0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
          0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
          0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\
          0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\
          0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\
          0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1
        \end{bmatrix}$
</pre></div>
</div>
<div class="highlight-center notranslate"><div class="highlight"><pre><span></span>![image](main/07/F7MDalgo.tikz){width=&quot;4cm&quot;}
</pre></div>
</div>
<p>Similar to the commands <span class="math notranslate nohighlight">\(\emph{symrcm}\)</span> and <span class="math notranslate nohighlight">\(\emph{colperm}\)</span>, in MATLAB
the command <span class="math notranslate nohighlight">\(\emph{symamd}\)</span> returns the approximate Minimum Degree
reordering of A to produce large blocks of zeros in the matrix. The
permutation matrix r is calculated such that <span class="math notranslate nohighlight">\(A(r,r)\)</span> tends to move rows
and columns with higher nonzero elements towards the end of the matrix -
similar to the Column Count algorithm.</p>
<p>Example MATLAB code:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  r = symamd(A);
  spy(A(r,r)),title(&#39;A(r,r)-Minimum Degree ordering by symamd&#39;)
  nz = nnz(A);
  pct = 100 / numel(A);
  xlabel(sprintf(&#39;nonzeros=%d (%.1f%%)&#39;,nz,nz*pct));
</pre></div>
</div>
<figure>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"><img src="main/07/MD_comb_1.tikz"
style="width:40.0%" alt="image" /></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><img src="main/07/MD_comb_2.tikz"
style="width:40.0%" alt="image" /></td>
</tr>
</tbody>
</table>
</div>
</figure>
</section>
<section id="comparison-between-various-ordering-schemes-and-fill-in-effect">
<h1><span class="section-number">8.8. </span>Comparison between various ordering schemes and fill-in effect<a class="headerlink" href="#comparison-between-various-ordering-schemes-and-fill-in-effect" title="Permalink to this headline">#</a></h1>
<p>For a more effective comparison we consider a symmetric <span class="math notranslate nohighlight">\(20 \times 20\)</span>
sparse matrix A, which was generated by using MATLAB’s <em>rand</em> command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  &gt;&gt; S = sparse(+(rand(20,20) &lt; 1/3)); % should allow &lt;10% nonzeros
  &gt;&gt; B=full(S);
  &gt;&gt; A=B&#39;*B  % makes A a symmetric matrix
</pre></div>
</div>
<p>Using the MATLAB <span class="math notranslate nohighlight">\(\emph{spy}\)</span> command the corresponding sparsity
patterns from the results of the reordering by the RCM, CC and MD
methods are summarised in Figure 6. Furthermore, using the MATLAB
command <span class="math notranslate nohighlight">\([L,U] = lu(A)\)</span> the upper triangular matrix in <span class="math notranslate nohighlight">\(U\)</span> for the full
matrix A and the reordered matrices are also shown in Figure 6. [ Note:
for the original matrix <span class="math notranslate nohighlight">\(bw =18\)</span> and for the RCM reordered matrix
<span class="math notranslate nohighlight">\(bw =7\)</span> were found using MATLAB]</p>
<figure>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"><img src="main/07/fig6a1.tikz"
style="width:35.0%" alt="image" /></td>
<td style="text-align: center;"><img src="main/07/fig6a2.tikz"
style="width:35.0%" alt="image" /></td>
</tr>
<tr class="even">
<td style="text-align: center;"><img src="main/07/fig6a3.tikz"
style="width:35.0%" alt="image" /></td>
<td style="text-align: center;"><img src="main/07/fig6a4.tikz"
style="width:35.0%" alt="image" /></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><img src="main/07/fig6a5.tikz"
style="width:35.0%" alt="image" /></td>
<td style="text-align: center;"><img src="main/07/fig6a6.tikz"
style="width:35.0%" alt="image" /></td>
</tr>
<tr class="even">
<td style="text-align: center;"><img src="main/07/fig6a7.tikz"
style="width:35.0%" alt="image" /></td>
<td style="text-align: center;"><img src="main/07/fig6a8.tikz"
style="width:35.0%" alt="image" /></td>
</tr>
</tbody>
</table>
</div>
<p>Figure 6. Comparison between reordering schemes for a <span
class="math inline">20 × 20</span> symmetric matrix</p>
</figure>
<p>In summary, the re-ordering or permutation of matrices provides a
pre-conditioning for the solution of matrices and the resulting matrix
is already nearly in LU factorization or banded form depending on the
chosen ordering method. Applying methods for the solution of full
matrices will produce more nonzero elements (fill-in effect) and no
computational advantage from the sparsity of matrix can be achieved. For
the <span class="math notranslate nohighlight">\(20 \times 20\)</span> matrix <span class="math notranslate nohighlight">\(A\)</span> the number of fill-in required to form the
upper triangular using LU factorization of the permuted matrix is shown
in the following table:</p>
<div class="highlight-center notranslate"><div class="highlight"><pre><span></span>   $20 \times 20$   Original Matrix   Reverse CM   Column Count   Min Degree
  ---------------- ----------------- ------------ -------------- ------------
   No. of nz in U        $66$            $54$          $53$          $58$
</pre></div>
</div>
<p>For large matrices with a high percentage of zero elements, reordering
process of matrices significantly reduces the number of fill-in and the
CPU processing time , as well as the amount of memory required for data
storage when solving large sparse linear system of equations. For a
<span class="math notranslate nohighlight">\(3000\times 3000\)</span> matrix as an example the effect of reordering on the
LU factors are presented in the following table:</p>
<div class="highlight-center notranslate"><div class="highlight"><pre><span></span>   $3000 \times 3000$   nnz (percentage)               CPU$(sec)$
  -------------------- ------------------ ----------- ------------
    Original Matrix        $1783708$        $(100)\%$   $5.500$
       Reverse CM           $862448$         $(48)\%$   $1.438$
      Column Count          $521582$         $(29)\%$   $1.016$
     Minimum Degree         $692034$         $(39)\%$   $1.047$
</pre></div>
</div>
<p><strong>[Example 7.4]{.underline}</strong> Consider the following sparse matrix and
its corresponding adjacency graph.</p>
<p><span class="math notranslate nohighlight">\(A=
          \begin{bmatrix}
        1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
        1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 \\
        0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
        0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\
        0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
        1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\
        1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
      \end{bmatrix}\)</span></p>
<p><img alt="image" src="chaps/08/main/07/ex74_2.tikz" />{width=”6cm”}</p>
<p>For the RCM and Column Count reordering methods, use the MATLAB commands
<span class="math notranslate nohighlight">\(symrcm(A)\)</span> and <span class="math notranslate nohighlight">\(colperm(A)\)</span> to find the corresponding reordered
matrices <span class="math notranslate nohighlight">\(C\)</span> and <span class="math notranslate nohighlight">\(D\)</span>. Plot the pattern of matrices <span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(C\)</span> and <span class="math notranslate nohighlight">\(D\)</span>.
Apply the MATLAB command <span class="math notranslate nohighlight">\([L,U]=lu(A)\)</span> for finding the LU factorisation
of matrices <span class="math notranslate nohighlight">\(A\)</span>, and similarly <span class="math notranslate nohighlight">\(C\)</span> and <span class="math notranslate nohighlight">\(D\)</span>. Plot the pattern of the
resulting matrices using <span class="math notranslate nohighlight">\(spy(lu(A))\)</span>, <span class="math notranslate nohighlight">\(spy(lu(C))\)</span> and <span class="math notranslate nohighlight">\(spy(lu(D))\)</span>.
Comment on the number of non-zero elements following LU factorisation.
Plot the upper triangular matrix U for each of the factorised matrices
and record the number of non-zero (nz) elements in U for each of the
resulting upper triangular matrices in a table. Comment on the
advantages of the LU factorisation and the effect of fill-in when using
ordered matrices. The three stages of the required solution together
with the MATLAB commands are summerised in Figure 7.</p>
<figure>
<div class="center">
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"><img src="main/07/image_orig1.tikz"
style="width:30.0%" alt="image" /></td>
<td style="text-align: center;"><img src="main/07/image_rcm1.tikz"
style="width:30.0%" alt="image" /></td>
<td style="text-align: center;"><img src="main/07/image_col1.tikz"
style="width:30.0%" alt="image" /></td>
</tr>
<tr class="even">
<td style="text-align: center;"><img src="main/07/image_orig2.tikz"
style="width:30.0%" alt="image" /></td>
<td style="text-align: center;"><img src="main/07/image_rcm2.tikz"
style="width:30.0%" alt="image" /></td>
<td style="text-align: center;"><img src="main/07/image_col2.tikz"
style="width:30.0%" alt="image" /></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><img src="main/07/image_orig3.tikz"
style="width:30.0%" alt="image" /></td>
<td style="text-align: center;"><img src="main/07/image_rcm3.tikz"
style="width:30.0%" alt="image" /></td>
<td style="text-align: center;"><img src="main/07/image_col3.tikz"
style="width:30.0%" alt="image" /></td>
</tr>
</tbody>
</table>
</div>
<p>Figure 7. Comparison of the LU factorisation and fill-in effect on
original and ordered matrices.</p>
</figure>
<p>Following LU factorisation, we find the number of non-zero elements in
various reordering methods in <span class="math notranslate nohighlight">\(U\)</span> as:</p>
<div class="highlight-center notranslate"><div class="highlight"><pre><span></span>    $8 \times 8$    Original Matrix   Reverse CM   Column Count
  ---------------- ----------------- ------------ --------------
   No. of nz in U        $24$            $17$          $18$
</pre></div>
</div>
<p>Hence, using the re-ordering methods, both RCM and Column Count,
significantly reduces the generation of fill-in elements compared to the
LU factorisation of the original matrix <span class="math notranslate nohighlight">\(A\)</span>, even for an <span class="math notranslate nohighlight">\(8\times8\)</span>
matrix.</p>
<p>Furthermore, the solution to the original linear algebraic system
contributes significantly to the total computational time for the
solution of stiff problems, as well as affecting the accuracy of the
solution (and hence, affecting the computational time). Note that
re-ordering enhances the computational accuracy through a reduction in
rounding errors (due to fewer computational steps, resulting from
reduced fill-in elements). In terms of application in the solutions of
large systems of stiff differential equations (which require treatment
of the associated Jacobinan metrix), the re-ordering of the system of
equations resulting from the Newton iteration will lead to the solution
of a banded matrix instead of a full matrix treatment, and hence
resulting in fewer fill-ins, more accurate solutions and shorter
computing time.</p>
<p><strong>[References]{.underline}</strong> MATLAB Help/documentation on Sparse
Matrices, e.g.:</p>
<p><a class="reference external" href="http://www.mathworks.co.uk/help/matlab/math/accessing-sparse-matrices.html">http://www.mathworks.co.uk/help/matlab/math/accessing-sparse-matrices.html</a></p>
<p><a class="reference external" href="http://www.mathworks.co.uk/help/matlab/examples/sparse-matrices.html">http://www.mathworks.co.uk/help/matlab/examples/sparse-matrices.html</a></p>
<p>Saad, Y., 2003. Iterative Methods for Sparse Linear System 2nd ed.
Philadelphia: SIAM- Society for Industrial and Applied Mathematics</p>
<p>Golub, G. and Van Loan, C., 1996g. Matrix Computations 3rd edition.
London: The Johns Hopkins University Press</p>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./chaps\08"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="chap08_4_storage.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">8.4. </span>Sparse Matrices Storage and Reordering</p>
      </div>
    </a>
    <a class="right-next"
       href="chap08_6_exercise.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">8.9. </span>Chapter 8 Exercises</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">8.5. Reordering and Matrix Bandwidth</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cuthill-and-mckee-reordering">8.5.1. Cuthill and McKee Reordering</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#column-count-reordering">8.6. Column Count Reordering</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#minimum-degree-reordering">8.7. Minimum Degree Reordering</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#comparison-between-various-ordering-schemes-and-fill-in-effect">8.8. Comparison between various ordering schemes and fill-in effect</a></li>
</ul>

  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Zhihua Ma
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>