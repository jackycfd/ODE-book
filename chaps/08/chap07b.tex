
\begin{center}
%    \newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
    \begin{tabular}{ P{2cm} | P{2cm} P{2cm} P{2cm} P{2cm} P{2cm} }
      \small Original nodes &
      \small No. of connections &
      \small Results/ Head &
      \small \phantom{\rule{1.9cm}{1pt}} Queue &
      \small \phantom{\rule{1.9cm}{1pt}} RCM &
      \small \phantom{\rule{1.9cm}{1pt}} New nodes\\
      \hline\normalsize
      1             & 1              & 1          & 5    &7    &1        \\
      2             & 3              & 5          & 3    &4    &2        \\
      3             & 2              & 3          & 2    &8    &3        \\
      4             & 1              & 2          & 6,8  &6    &4        \\
      5             & 2              & 6          & -    &2    &5        \\
      6             & 2              & 8          & -    &3    &6        \\
      7             & 1              & 4          & 7    &5    &7        \\
      8             & 2              & 7          & -    &1    &8        \\
    \end{tabular}
\end{center}
  
  %\vskip 5pt
  \noindent
  Note that the labels of new nodes are the reverse of the elements in the array
  Results.  See below the re-ordered matrix and the adjacency graph (note the
  diagram remains unchanged, but nodes are now relabelled).
  \vskip 5pt
  \noindent
  \begin{table}[H]
    \begin{minipage}[b]{0.50\linewidth}
      \vskip 5pt
      \begin{center}
        $B=
        \begin{bmatrix}
          1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
          1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
          0 & 0 & 1 & 1 & 1 & 0 & 0 & 0 \\
          0 & 0 & 1 & 1 & 1 & 0 & 0 & 0 \\
          0 & 0 & 1 & 1 & 1 & 1 & 0 & 0 \\
          0 & 0 & 0 & 0 & 1 & 1 & 1 & 0 \\
          0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 \\
          0 & 0 & 0 & 0 & 0 & 0 & 1 & 1
        \end{bmatrix}$
      \end{center}
      \vspace{5mm}
    \end{minipage}
    \begin{minipage}[b]{0.49\linewidth}
      \begin{center}
        \includegraphics[width=5cm]{main/07/Fig7b.tikz}
      \end{center}
    \end{minipage}
  \end{table}
  \vskip -12pt
  \noindent
  It can be seen that the algorithm keeps all nonzero elements close to the
  diagonal.  You can see visibly that there are more zero elements below and above
  the main diagonal and nonzero elements are close to the main diagonal and the
  re-ordered matrix exhibits a banded structure.
  \vskip 6pt
  \noindent
  Using MATLAB the bandwidths of the original matrix A and the reordered matrix B
  can be found as:-
  \vskip 12pt
  \noindent
  \ttfamily
  \begin{lstlisting}
  >> [i,j]=find(A); %returns the row and col indices
                    %of the nonzero entries
  >> bw=max(i-j)
  bw =6
  
  >> [i,j]=find(B);
  >> bw=max(i-j)
  bw =2
  \end{lstlisting}
  \rmfamily
  \vskip 12pt
  \noindent
  i.e. The (half) bandwidth of the matrix has been reduced to 2 instead of 6;
  hence, the full bandwidth of the matrices A and B are 13 and 5 respectively.
  \vskip 12pt
  \noindent
  Note that the relabeling described above used the reverse of the array RCM of
  the reordered nodes, hence this is the Reverse Cuthill-McKee (RCM) re-ordering
  technique.  In the original Cuthill-McKee (CM) algorithm, the elements of array
  Results are relabelled without reversing the elements. i.e.
  \vskip 10pt
  \noindent
  \begin{center}
      \begin{tabular}{ r | l l l l l l l l l l }
      Original nodes  & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\
      \hline
      Cuthill-McKee   & 1 & 5 & 3 & 2 & 6 & 8 & 4 & 7 \\
      Reverse CM      & 7 & 4 & 8 & 6 & 2 & 3 & 5 & 1 \\
      \end{tabular}
  \end{center}
  \noindent
  \vskip 10pt
  
  %{\bf\underline {4.2 MATLAB Commands}}
  \noindent
  In MATLAB, the command $symrcm(A)$ returns the symmetric reverse Cuthill-McKee
  ordering of A. This is a permutation matrix p such that $A(p,p)$ tends to have
  its nonzero elements closer to the main diagonal.
  \vskip 6pt
  \noindent
  Example MATLAB code:
  \noindent
  \begin{lstlisting}
  p = symrcm(A);
  spy(A(p,p)), title('A(p,p) after Cuthill-McKee ordering')
  nz = nnz(A);
  pct = 100/numel(A);
  xlabel(sprintf('nonzeros=%d (%.1f%%)',nz,nz*pct));
  \end{lstlisting}
  
  %\vspace{5mm}
  \begin{figure}[H]
    \begin{center}
        \scriptsize\includegraphics[width=6cm]{main/07/example7_1fig1.tikz}
    \end{center}
  \end{figure}
  
  \newpage
  \noindent
  \rmfamily
  Figure 5 below shows the nonzero pattern of the original matrix A, the ordered
  matrix B, matrix C, ordered by the CM method, and matrix D is found by using the
  MATLAB function $\emph{symrcm}$:-
  \begin{figure}[H]
    \begin{center}
      \tiny
      \begin{tabular}{ccc}
        \includegraphics[width=6cm]{main/07/example7_1sub1.tikz}&&
        \includegraphics[width=6cm]{main/07/example7_1sub2.tikz}\\
        \includegraphics[width=6cm]{main/07/example7_1sub3.tikz}&&
        \includegraphics[width=6cm]{main/07/example7_1sub4.tikz}\\
      \end{tabular}
    \end{center}
  \end{figure}
  \vskip 10pt
  Note that the half bandwidth of the reordered matrix $C$, using the original
  Cuthill-Mckee method is $bw =5$, and the half bandwidth of the reordered matrix
  $D$ is $bw =2$, using the MATLAB function $sysmrcm$ for the reverse
  Cuthill-Mckee is $bw =2$, i.e. the same as that for matrix $B$. Hence, the
  Reverse Cuthill-Mckee algorithm for bandwidth reduction of sparse matrices seems
  to be the most effective reordering method.
  \vskip 6pt
  \noindent
  \newpage
  \rmfamily
  \vskip 12pt
  \noindent
  %{\bf\underline {4.2 Column Count Reordering}}
  \subsection{Column Count Reordering}
  \vskip 10pt
  \noindent
  The idea of the column count reordering algorithm is to move rows and columns
  with higher nonzero count towards the end of the matrix. This algorithm reduces
  the time and storage for computing matrix operations such as the LU
  factorization and the Cholesky factorization, but its performance is not
  consistent overall and depends on the original matrix.
  \vskip 10pt
  \noindent
  {\bf\underline {Example 7.2}}
  \vskip 2pt
  \noindent
  Consider the sparse matrix and its corresponding adjacency graph from Example
  7.1:
  \vskip 4pt
  \noindent
  \begin{table}[H]
    \begin{minipage}[b]{0.50\linewidth}
      \vskip 2pt
      \begin{center}
        $A=
        \begin{bmatrix}
          1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\
          0 & 1 & 1 & 0 & 0 & 1 & 0 & 1 \\
          0 & 1 & 1 & 0 & 1 & 0 & 0 & 0 \\
          0 & 0 & 0 & 1 & 0 & 0 & 1 & 0 \\
          1 & 0 & 1 & 0 & 1 & 0 & 0 & 0 \\
          0 & 1 & 0 & 0 & 0 & 1 & 0 & 1 \\
          0 & 0 & 0 & 1 & 0 & 0 & 1 & 0 \\
          0 & 1 & 0 & 0 & 0 & 1 & 0 & 1
        \end{bmatrix}$
      \end{center}
      \vspace{5mm}
    \end{minipage}
    \begin{minipage}[b]{0.49\linewidth}
      \begin{center}
        \includegraphics[width=5cm]{main/07/Fig7a.tikz}
      \end{center}
    \end{minipage}
  \end{table}
  \vskip -10pt
  The degrees of all vertices are obtained in the following:
  \vskip 10pt
  \noindent
  \begin{center}
    \begin{tabular}{ l | l l l l l l l l }
      vertex          & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\
      \hline
      no. of degree   & 1 & 3 & 2 & 1 & 2 & 2 & 1 & 2 \\
    \end{tabular}
  \end{center}
  \rmfamily
  \noindent
  \vskip 5pt
  Since vertex 7 has the least degrees, it is labelled as 1 - (Note: since
  vertices 1, 4, and 7 have the same number of degrees, therefore the new labels
  are interchangeable, as any of these vertices can be chosen in any order) and
  then vertices 4 and 1 are labelled (again since vertices 4 and 1 have the same
  number of degrees, therefore the new labels are interchangeable). The algorithm
  is then continued in the same steps until complete labelling is obtained as
  shown:
  \noindent
    \begin{center}
      \begin{tabular}{ l | l l l l l l l l }
      new vertex   & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\
      \hline
      old vertex   & 7 & 4 & 1 & 8 & 6 & 5 & 3 & 2 \\
    \end{tabular}
  \end{center}
  \noindent
  \vskip 7pt
  The resulting adjacency matrix and graph are shown below:
  \begin{table}[H]
    \begin{minipage}[b]{0.49\linewidth}
      \vskip 5pt
      \begin{center}
        $CC=
        \begin{bmatrix}
          1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
          1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
          0 & 0 & 1 & 0 & 0 & 1 & 0 & 0 \\
          0 & 0 & 0 & 1 & 1 & 0 & 0 & 1 \\
          0 & 0 & 0 & 1 & 1 & 0 & 0 & 1 \\
          0 & 0 & 1 & 0 & 0 & 1 & 1 & 0 \\
          0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 \\
          0 & 0 & 0 & 1 & 1 & 0 & 1 & 1
        \end{bmatrix}$
      \end{center}
      \vspace{5mm}
    \end{minipage}
    \begin{minipage}[b]{0.5\linewidth}
      \includegraphics[width=5cm]{main/07/F7CCalog.tikz}
    \end{minipage}
  \end{table}
  \noindent
  Similar to the command $\emph{symrcm}$ for RCM reordering, in MATLAB the command
  $\emph{colperm}$ returns the column count reordering of A. This is a permutation
  matrix q such that $A(q,q)$ tends to move rows and columns with higher nonzero
  count towards the end of the matrix (a down-arrow effect).
  
  Example MATLAB code:
  \begin{lstlisting}
  q = colperm(A);
  spy(A(q,q)),title('A(q,q)-Column Count ordering by colperm')
  nz = nnz(A);
  pct = 100 / numel(A);
  xlabel(sprintf('nonzeros=%d (%.1f%%)',nz,nz*pct));
  \end{lstlisting}
  \begin{figure}[H]
    \begin{center}
      \scriptsize
      \begin{tabular}{ccc}
        \includegraphics[width=0.4\textwidth]{main/07/cc_comb_1.tikz}
        &&
        \includegraphics[width=0.4\textwidth]{main/07/cc_comb_2.tikz}
      \end{tabular}
    \end{center}
  \end{figure}
  
  \subsection{Minimum Degree Reordering}
  The minimum degree algorithm attempts to reduce the fill-in caused by
  elimination such as Gaussian elimination, LU decomposition or the Cholesky
  decomposition. The computational costs of this algorithm is inexpensive, and it
  is easy to apply and effective for most problems which are not too large.
  However, most mathematical software packages such as MATLAB use an approximation
  minimum degree, rather than the exact degree to minimise the computational costs.
  The minimum degree algorithm is re-labelling of the vertices in ascending degree
  order. Nodes with lower degrees are labelled early to reduce adding many
  fill-ins.
  
  \newpage
  {\bf\underline {Example 7.3}}
  \vskip 2pt
  \noindent
  Consider the sparse matrix and its corresponding adjacency graph from Example
  7.1:
  %\vskip 6pt
  \noindent
  \begin{table}[H]
    \begin{minipage}[]{0.50\linewidth}
      \begin{center}
        $A=
        \begin{bmatrix}
          1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\
          0 & 1 & 1 & 0 & 0 & 1 & 0 & 1 \\
          0 & 1 & 1 & 0 & 1 & 0 & 0 & 0 \\
          0 & 0 & 0 & 1 & 0 & 0 & 1 & 0 \\
          1 & 0 & 1 & 0 & 1 & 0 & 0 & 0 \\
          0 & 1 & 0 & 0 & 0 & 1 & 0 & 1 \\
          0 & 0 & 0 & 1 & 0 & 0 & 1 & 0 \\
          0 & 1 & 0 & 0 & 0 & 1 & 0 & 1
       \end{bmatrix}$
      \end{center}
      %\vspace{2mm}
    \end{minipage}
    \begin{minipage}[]{0.49\linewidth}
      \begin{center}
        \includegraphics[width=4cm]{main/07/Fig7a.tikz}
      \end{center}
    \end{minipage}
  \end{table}
  
  The minimum degree algorithm is re-labelling of the vertices in ascending degree
  order. Nodes with lower degrees are labelled early to reduce adding many
  fill-ins.
  
  The degrees of all vertices are shown in the following table:
  %\vskip 2pt
  %\noindent
      \begin{center}
          \begin{tabular}{ r | l l l l l l l l }
          vertex          & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\
          \hline
          no. of degree   & 1 & 3 & 2 & 1 & 2 & 2 & 1 & 2 \\
      \end{tabular}
  \end{center}
  %\vskip 10pt
  %\noindent
  where vertex 7 has the least degrees, then vertex 7 is numbered with first as 1.
  Since vertex 7 is connected to vertex 4, then vertex 4 must be updated by
  subtracting 1 (if it is already 1 then just write it down as 1 and number it
  immediately after 7) as shown in the following Table - where the eliminated node
  is represented by X , and the vertex is numbered with a new label. Note: if no
  tie-breaking strategy has been established, all three vertices 1, 4, and 7 can
  be selected in this case, and proceed to elimination. The completed ordering
  using the Minimum Degree algorithm is shown in the following table, together
  with the resulting adjacency matrix and graph:
  %\vskip 2pt
  %\noindent
  \begin{center}
      \begin{tabular}{cc|cccccccc}
          %\hline
          \multicolumn{2}{p{1.5cm}|}{} &
          \multicolumn{8}{c}{vertex and no. of degree} \\
          %\cline{3-10}
          \small
              &               & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\
              &New ordering   & 1 & 3 & 2 & 1 & 2 & 2 & 1 & 2 \\
          \hline
           1  &(7)            & 1 & 3 & 2 & 1 & 2 & 2 & X & 2 \\
           2  &(4)            & 1 & 3 & 2 & X & 2 & 2 & X & 2 \\
           3  &(1)            & X & 3 & 2 & X & 1 & 2 & X & 2 \\
           4  &(5)            & X & 3 & 1 & X & X & 2 & X & 2 \\
           5  &(3)            & X & 2 & X & X & X & 2 & X & 2 \\
           6  &(6)            & X & 1 & X & X & X & X & X & 1 \\
           7  &(8)            & X & 1 & X & X & X & X & X & X \\
           8  &(2)            & X & X & X & X & X & X & X & X \\
      \end{tabular}
  \end{center}
  %\noindent
  
  %\begin{table}[H]
    \begin{minipage}[]{0.50\linewidth}
      %\vskip 5pt
      \begin{center}
        $MD=
        \begin{bmatrix}
          1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
          1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
          0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 \\
          0 & 0 & 1 & 1 & 1 & 0 & 0 & 0 \\
          0 & 0 & 0 & 1 & 1 & 0 & 0 & 1 \\
          0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 \\
          0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 \\
          0 & 0 & 0 & 0 & 1 & 1 & 1 & 1
        \end{bmatrix}$
      \end{center}
      %\vspace{5mm}
    \end{minipage}
    \begin{minipage}[]{0.49\linewidth}
      \begin{center}
      \includegraphics[width=4cm]{main/07/F7MDalgo.tikz}
      \end{center}
    \end{minipage}
  %\end{table}
  
  %\newpage
  %\noindent
  Similar to the commands $\emph{symrcm}$ and $\emph{colperm}$, in MATLAB the
  command $\emph{symamd}$ returns the approximate Minimum Degree reordering of A
  to produce large blocks of zeros in the matrix. The permutation matrix r is
  calculated such that $A(r,r)$ tends to move rows and columns with higher nonzero
  elements towards the end of the matrix - similar to the Column Count algorithm.
  %\vskip 10pt
  
  Example MATLAB code:
  %\vskip 2pt
  {%\small
  \begin{lstlisting}
  r = symamd(A);
  spy(A(r,r)),title('A(r,r)-Minimum Degree ordering by symamd')
  nz = nnz(A);
  pct = 100 / numel(A);
  xlabel(sprintf('nonzeros=%d (%.1f%%)',nz,nz*pct));
  \end{lstlisting}}
  \begin{figure}[H]
    \begin{center}
      \scriptsize
      \begin{tabular}{ccc}
        \includegraphics[width=0.4\textwidth]{main/07/MD_comb_1.tikz}
        &&
        \includegraphics[width=0.4\textwidth]{main/07/MD_comb_2.tikz}
      \end{tabular}
    \end{center}
  \end{figure}
  %\noindent
  %\vskip 10pt
  %\noindent
  %%{\bf\underline {4.4 Comparison between various ordering schemes and fill-in effect}}
  %\vskip 10pt
  %\noindent
  
  %\newpage
  
  \subsection{Comparison between various ordering schemes and fill-in effect}
  For a more effective comparison we consider a symmetric $20 \times 20$ sparse
  matrix A, which was generated by using MATLAB's {\it{rand}} command:
  \begin{lstlisting}
  >> S = sparse(+(rand(20,20) < 1/3)); % should allow <10% nonzeros
  >> B=full(S);
  >> A=B'*B  % makes A a symmetric matrix
  \end{lstlisting}
  
  Using the MATLAB $\emph{spy}$ command the corresponding sparsity patterns from
  the results of the reordering by the RCM, CC and MD methods are summarised in
  Figure 6.  Furthermore, using the MATLAB command $[L,U] = lu(A)$ the upper
  triangular matrix in $U$ for the full matrix A and the reordered matrices are
  also shown in Figure 6. [ Note: for the original matrix $bw =18$ and for the RCM
  reordered matrix $bw =7$ were found using MATLAB]
  \newpage
  
  \begin{figure}[H]
    \begin{center}
      \begin{tabular}{cc}
        \scriptsize\includegraphics[width=0.35\textwidth]{main/07/fig6a1.tikz} &
        \scriptsize\includegraphics[width=0.35\textwidth]{main/07/fig6a2.tikz}\\
        \scriptsize\includegraphics[width=0.35\textwidth]{main/07/fig6a3.tikz} &
        \scriptsize\includegraphics[width=0.35\textwidth]{main/07/fig6a4.tikz}\\
        \scriptsize\includegraphics[width=0.35\textwidth]{main/07/fig6a5.tikz} &
        \scriptsize\includegraphics[width=0.35\textwidth]{main/07/fig6a6.tikz}\\
        \scriptsize\includegraphics[width=0.35\textwidth]{main/07/fig6a7.tikz} &
        \scriptsize\includegraphics[width=0.35\textwidth]{main/07/fig6a8.tikz}\\
      \end{tabular}
    \end{center}
    Figure 6. Comparison between reordering schemes for a $20 \times 20$ symmetric matrix
  \end{figure}
  \vskip 10pt
  \noindent
  
  In summary, the re-ordering or permutation of matrices provides a
  pre-conditioning for the solution of matrices and the resulting matrix is
  already nearly in LU factorization or banded form depending on the chosen
  ordering method. Applying methods for the solution of full matrices will produce
  more nonzero elements (fill-in effect) and no computational advantage from the
  sparsity of matrix can be achieved.
  \vskip 10pt
  \noindent
  For the $20 \times 20$ matrix $A$ the number of fill-in required to form the
  upper triangular using LU factorization of the permuted matrix is shown in the
  following table:
  
  \vskip 10pt
  \noindent
  \begin{center}
      \begin{tabular}{c|cccc}
          $20 \times 20$ & Original Matrix & Reverse CM & Column Count & Min Degree  \\ \hline
          No. of nz in U &$ 66 $           & $ 54 $      & $ 53 $        &$ 58 $  \\
      \end{tabular}
  \end{center}
  \vskip 10pt
  \noindent
  
  For large matrices with a high percentage of zero elements, reordering process
  of matrices significantly reduces the number of fill-in and the CPU processing
  time , as well as the amount of memory required for data storage when solving
  large sparse linear system of equations.
  \vskip 10pt
  \noindent
  For a $3000\times 3000$ matrix as an example the effect of reordering on the LU
  factors are presented in the following table:
  
  \vskip 10pt
  \noindent
  \begin{center}
    \begin{tabular}{c|cr|c}
      $3000 \times 3000$ & \multicolumn{2}{c|}{nnz (percentage)} &  CPU$(sec)$ \\ \hline
      Original Matrix    &$ 1783708$ &$(100)\%$& $5.500$ \\
      Reverse CM         &$ 862448$  &$(48)\% $& $1.438$ \\
      Column Count       &$ 521582$  &$(29)\% $& $1.016$ \\
      Minimum Degree     &$ 692034$  &$(39)\% $& $1.047$ \\
    \end{tabular}
  \end{center}
  \vskip 5pt
  \noindent
  
  \vskip 4pt
  \noindent
  {\bf\underline {Example 7.4}}
  \vskip 2pt
  \noindent
  Consider the following sparse matrix and its corresponding adjacency graph.
  \vskip 1pt
  \noindent
  \begin{table}[H]
    \begin{minipage}[b]{0.5\linewidth}
      \vskip 2pt
          %\begin{center}
      $A=
          \begin{bmatrix}
        1 & 1 & 0 & 0 & 0 & 0 & 1 & 1 \\
        1 & 1 & 0 & 0 & 1 & 1 & 1 & 0 \\
        0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 \\
        0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 \\
        0 & 1 & 0 & 0 & 1 & 0 & 1 & 0 \\
        0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 \\
        1 & 1 & 1 & 0 & 1 & 0 & 1 & 0 \\
        1 & 0 & 1 & 0 & 0 & 0 & 0 & 1
      \end{bmatrix}$
          %\end{center}
      \vspace{-5mm}
    \end{minipage}
    \begin{minipage}[b]{0.59\linewidth}
      %\begin{center}
      \includegraphics[width=6cm]{main/07/ex74_2.tikz}
          %\end{center}
    \end{minipage}
  \end{table}
  \vskip 10pt
  
  For the RCM and Column Count reordering methods, use the MATLAB commands
  $symrcm(A)$ and $colperm(A)$ to find the corresponding reordered matrices $C$
  and $D$. Plot the pattern of matrices $A$, $C$ and $D$. Apply the MATLAB command
  $[L,U]=lu(A)$ for finding the LU factorisation of matrices $A$, and similarly $C$
  and $D$. Plot the pattern of the resulting matrices using $spy(lu(A))$,
  $spy(lu(C))$ and $spy(lu(D))$. Comment on the number of non-zero elements
  following LU factorisation. Plot the upper triangular matrix U for each of the
  factorised matrices and record the number of non-zero (nz) elements in U for
  each of the resulting upper triangular matrices  in a table. Comment on the
  advantages of the LU factorisation and the effect of fill-in when using ordered
  matrices.
  \rmfamily
  The three stages of the required solution together with the MATLAB commands are
  summerised in Figure 7.
  %\newpage
  
  \begin{figure}[H]
    \begin{center}
      \begin{tabular}{ccc}
        \scriptsize\includegraphics[width=0.3\textwidth]{main/07/image_orig1.tikz} &
        \scriptsize\includegraphics[width=0.3\textwidth]{main/07/image_rcm1.tikz}  &
        \scriptsize\includegraphics[width=0.3\textwidth]{main/07/image_col1.tikz} \\
        \scriptsize\includegraphics[width=0.3\textwidth]{main/07/image_orig2.tikz} &
        \scriptsize\includegraphics[width=0.3\textwidth]{main/07/image_rcm2.tikz}  &
        \scriptsize\includegraphics[width=0.3\textwidth]{main/07/image_col2.tikz} \\
        \scriptsize\includegraphics[width=0.3\textwidth]{main/07/image_orig3.tikz} &
        \scriptsize\includegraphics[width=0.3\textwidth]{main/07/image_rcm3.tikz}  &
        \scriptsize\includegraphics[width=0.3\textwidth]{main/07/image_col3.tikz} \\
      \end{tabular}
    \end{center}
    \vskip 10pt
    Figure 7. Comparison of the LU factorisation and fill-in effect on original
    and ordered matrices.
  \end{figure}
  
  \vskip 10pt
  
  \noindent
  Following LU factorisation, we find the number of non-zero elements in various
  reordering methods in $U$ as:
  
  \vskip 5pt
  \noindent
  \begin{center}
    \begin{tabular}{c|ccc}
      $8 \times 8$ & Original Matrix & Reverse CM & Column Count  \\ \hline
      No. of nz in U     &$ 24 $           & $ 17 $      & $ 18 $ \\
    \end{tabular}
  \end{center}
  \vskip 5pt
  \noindent
  Hence, using the re-ordering methods, both RCM and Column Count, significantly
  reduces the generation of fill-in elements compared to the LU factorisation of
  the original matrix $A$, even for an $8\times8$ matrix.
  
  \noindent
  Furthermore, the solution to the original linear algebraic system contributes
  significantly to the total computational time for the solution of stiff
  problems, as well as affecting the accuracy of the solution (and hence,
  affecting the computational time). Note that re-ordering enhances the
  computational accuracy through a reduction in rounding errors (due to fewer
  computational steps, resulting from reduced fill-in elements). In terms of
  application in the solutions of large systems of stiff differential equations
  (which require treatment of the associated Jacobinan metrix), the re-ordering of
  the system of equations resulting from the Newton iteration will lead to the
  solution of a banded matrix instead of a full matrix treatment, and hence
  resulting in fewer fill-ins, more accurate solutions and shorter computing time.
  
  \vskip 20pt
  \noindent
  {\bf\underline {References}}
  \vskip 10pt
  \noindent
  MATLAB Help/documentation on Sparse Matrices, e.g.:
  
  http://www.mathworks.co.uk/help/matlab/math/accessing-sparse-matrices.html
  
  http://www.mathworks.co.uk/help/matlab/examples/sparse-matrices.html
  
  
  \noindent
  Saad, Y., 2003. Iterative Methods for Sparse Linear System 2nd ed. Philadelphia:
  SIAM- Society for Industrial and Applied Mathematics
  
  \noindent
  Golub, G. and Van Loan, C., 1996g. Matrix Computations 3rd edition. London: The
  Johns Hopkins University Press
  
  \newpage
  
  {\bf\underline {Exercise (7)}}
  
  \vskip 4pt
  \noindent
  \begin{enumerate}
  \item (a) Write a Matlab mfile that produces the adjacency graph for the
  symmetric matrix A given in Example 4. (b) Modify your mfile and repeat for the 
  matrix A:
  A=[1 1 0 0 0 1, 1 1 0 0 1 0, 0 0 1 0 1 0, 0 0 0 1 0 1, 0 1 1 0 1 0, 1 0 0 1 0 1].
  \vskip 2pt
  \item {Consider the following adjacency graph with 10 nodes:
  \vskip -6pt
  \begin{table}[H]
  \hspace*{20mm} \includegraphics{main/07/ch7ex3.tikz}
  \end{table}
  \parskip -10pt
  \noindent
  Show the corresponding adjacency matrix $A$ and calculate its bandwidth using
  the MATLAB command \emph{bandwidth}. Reorder the matrix $A$ using the Cuthill-McKee (CM)
  algorithm and label the corresponding matrix $B$. Reorder the matrix $A$ using
  the RCM algorithm and label the corresponding matrix C. Compare the bandwidths
  of matrices $A$, $B$ and $C$ and comment on the computational efficiency when
  using matrix re-ordering. Plot the sparsity pattern of matrices $A$, $B$, and
  $C$, and verify your results by using the MATLAB function {\it symrcm(A)}.
  Reorder the Matrix $A$ by Column Count (label $D$) and Minimum Degree (label
  $M$) schemes, write down the corresponding adjacency matrices and plot the
  adjacency graphs. For the three schemes RCM, CC and MD (i.e. matrices $C$, $D$
  and $M$), perform LU factorisation and record the number of fill-in elements in
  a table, prepare a summary result table (similar to Figure 6 shown in the
  lecture notes) and comment.}
  \vskip 4pt
  \item Repeat question 2 with the following adjacency graph with 9 nodes.
  \begin{figure}[H]
  \hspace*{20mm}$\includegraphics{main/07/ch7ex2v2.tikz}$
  \end{figure}
  \parskip -10pt
  \noindent
  Calculate the storage in units of bytes for the full and sparse matrix $A$ and
  the reordered Matrices $D$ (Column Count) and $M$ (Minimum Degree), and comment.
  \end{enumerate}
  
  \input{main/07/chap07_answers}